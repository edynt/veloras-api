// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rate_limits.sql

package gen

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRateLimitRecord = `-- name: CreateRateLimitRecord :one
INSERT INTO rate_limits (user_id, action, ip_address, attempts, window_start)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, action, ip_address, attempts, window_start, created_at, updated_at
`

type CreateRateLimitRecordParams struct {
	UserID      pgtype.UUID
	Action      string
	IpAddress   netip.Addr
	Attempts    pgtype.Int4
	WindowStart int64
}

func (q *Queries) CreateRateLimitRecord(ctx context.Context, arg CreateRateLimitRecordParams) (RateLimit, error) {
	row := q.db.QueryRow(ctx, createRateLimitRecord,
		arg.UserID,
		arg.Action,
		arg.IpAddress,
		arg.Attempts,
		arg.WindowStart,
	)
	var i RateLimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.IpAddress,
		&i.Attempts,
		&i.WindowStart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpiredRateLimits = `-- name: DeleteExpiredRateLimits :exec
DELETE FROM rate_limits WHERE window_start < $1
`

func (q *Queries) DeleteExpiredRateLimits(ctx context.Context, windowStart int64) error {
	_, err := q.db.Exec(ctx, deleteExpiredRateLimits, windowStart)
	return err
}

const getRateLimitByIP = `-- name: GetRateLimitByIP :one
SELECT id, user_id, action, ip_address, attempts, window_start, created_at, updated_at FROM rate_limits WHERE ip_address = $1 AND action = $2
`

type GetRateLimitByIPParams struct {
	IpAddress netip.Addr
	Action    string
}

func (q *Queries) GetRateLimitByIP(ctx context.Context, arg GetRateLimitByIPParams) (RateLimit, error) {
	row := q.db.QueryRow(ctx, getRateLimitByIP, arg.IpAddress, arg.Action)
	var i RateLimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.IpAddress,
		&i.Attempts,
		&i.WindowStart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRateLimitRecord = `-- name: GetRateLimitRecord :one
SELECT id, user_id, action, ip_address, attempts, window_start, created_at, updated_at FROM rate_limits WHERE user_id = $1 AND action = $2 AND ip_address = $3
`

type GetRateLimitRecordParams struct {
	UserID    pgtype.UUID
	Action    string
	IpAddress netip.Addr
}

func (q *Queries) GetRateLimitRecord(ctx context.Context, arg GetRateLimitRecordParams) (RateLimit, error) {
	row := q.db.QueryRow(ctx, getRateLimitRecord, arg.UserID, arg.Action, arg.IpAddress)
	var i RateLimit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.IpAddress,
		&i.Attempts,
		&i.WindowStart,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetRateLimit = `-- name: ResetRateLimit :exec
UPDATE rate_limits SET attempts = 0, window_start = $1 WHERE id = $2
`

type ResetRateLimitParams struct {
	WindowStart int64
	ID          pgtype.UUID
}

func (q *Queries) ResetRateLimit(ctx context.Context, arg ResetRateLimitParams) error {
	_, err := q.db.Exec(ctx, resetRateLimit, arg.WindowStart, arg.ID)
	return err
}

const updateRateLimitAttempts = `-- name: UpdateRateLimitAttempts :exec
UPDATE rate_limits SET attempts = $1, window_start = $2 WHERE id = $3
`

type UpdateRateLimitAttemptsParams struct {
	Attempts    pgtype.Int4
	WindowStart int64
	ID          pgtype.UUID
}

func (q *Queries) UpdateRateLimitAttempts(ctx context.Context, arg UpdateRateLimitAttemptsParams) error {
	_, err := q.db.Exec(ctx, updateRateLimitAttempts, arg.Attempts, arg.WindowStart, arg.ID)
	return err
}
